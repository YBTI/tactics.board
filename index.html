<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Soccer Tactics Board v4.0</title>
    <style>
        :root {
            --bg-color: #222;
            --text-color: #eee;
            --pitch-color: #4da654;
            --accent-color: #3498db;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", Arial, sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            /* ã‚¹ãƒãƒ›ã§ã®ãƒã‚¦ãƒ³ã‚¹ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é˜²æ­¢ */
            overscroll-behavior: none; 
        }

        h1 { margin: 5px 0 15px 0; font-size: 20px; text-align: center; }

        /* ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ: PCã¯æ¨ªä¸¦ã³ã€ã‚¹ãƒãƒ›ã¯ç¸¦ä¸¦ã³ */
        .main-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            width: 100%;
            max-width: 1000px;
            justify-content: center;
            align-items: flex-start;
        }

        /* ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ */
        .sidebar {
            background: #333;
            padding: 15px;
            border-radius: 8px;
            width: 100%; /* ã‚¹ãƒãƒ›ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ */
            max-width: 350px; /* PCã§ã®æœ€å¤§å¹… */
            display: flex;
            flex-direction: column;
            gap: 15px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        /* ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚¨ãƒªã‚¢ */
        .canvas-area {
            width: 100%;
            max-width: 800px; /* PCã§ã®æœ€å¤§å¹… */
            position: relative;
        }

        /* Canvasã®ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–è¨­å®š */
        canvas {
            background-color: var(--pitch-color);
            border: 2px solid white;
            border-radius: 4px;
            cursor: crosshair;
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
            
            /* ã“ã“ãŒé‡è¦: å†…éƒ¨è§£åƒåº¦ã‚’ä¿ã£ãŸã¾ã¾è¦‹ãŸç›®ã ã‘ç¸®å° */
            width: 100%; 
            height: auto; 
            display: block;
            touch-action: none; /* ã‚¹ãƒãƒ›ã§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å¹²æ¸‰ã‚’é˜²ã */
        }

        /* ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«å‘¨ã‚Š */
        .control-group {
            border-bottom: 1px solid #555;
            padding-bottom: 10px;
        }
        .control-group:last-child { border-bottom: none; }
        
        h3 { margin: 0 0 8px 0; font-size: 14px; color: #aaa; text-transform: uppercase; }

        .btn-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 5px;
        }

        button {
            width: 100%;
            padding: 8px 4px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            font-weight: bold;
            font-size: 11px;
            transition: opacity 0.2s;
        }
        button:hover { opacity: 0.8; }
        button:active { transform: scale(0.98); }

        .btn-home { background-color: #e74c3c; color: white; }
        .btn-away { background-color: #3498db; color: white; }
        .btn-gk { border: 2px solid #f1c40f; color: #f1c40f; background: transparent; }
        .btn-cone { background-color: #e67e22; color: white; grid-column: span 4; margin-top: 5px;}
        .btn-save { background-color: #2ecc71; color: white; font-size: 14px; padding: 10px; margin-bottom: 5px;}
        .btn-gray { background-color: #7f8c8d; color: white; }
        .btn-danger { background-color: #c0392b; color: white; }

        .radio-list {
            display: flex;
            flex-wrap: wrap; /* ã‚¹ãƒãƒ›ã§æŠ˜ã‚Šè¿”ã— */
            gap: 10px;
        }
        .radio-label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: 13px;
            background: #444;
            padding: 6px 10px;
            border-radius: 20px;
        }
        .radio-label input { margin-right: 5px; }
        .radio-label:has(input:checked) { background: #666; border: 1px solid #aaa; }

        .trash-info { font-size: 10px; color: #aaa; text-align: center; margin-top: 5px; }

        /* PCç”»é¢å‘ã‘ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆèª¿æ•´ */
        @media (min-width: 850px) {
            .sidebar { width: 250px; }
            .btn-grid { grid-template-columns: 1fr 1fr; }
            .btn-cone { grid-column: span 2; }
            .radio-list { flex-direction: column; gap: 5px; }
            .radio-label { background: transparent; border-radius: 0; padding: 4px; }
            .radio-label:has(input:checked) { background: transparent; border: none; font-weight: bold; color: white; }
        }
    </style>
</head>
<body>

    <h1>âš½ï¸ Tactics Board v4.0</h1>

    <div class="main-container">
        <div class="canvas-area">
            <canvas id="tacticsBoard" width="800" height="520"></canvas>
        </div>

        <div class="sidebar">
            
            <div class="control-group">
                <button class="btn-save" onclick="downloadImage()">ğŸ“· ç”»åƒã¨ã—ã¦ä¿å­˜</button>
            </div>

            <div class="control-group">
                <h3>Tools</h3>
                <div class="radio-list">
                    <label class="radio-label"><input type="radio" name="tool" value="move" checked onchange="setTool('move')">âœ‹ ç§»å‹•</label>
                    <label class="radio-label"><input type="radio" name="tool" value="arrow-solid" onchange="setTool('arrow-solid')">â”€â”€ ãƒ‘ã‚¹</label>
                    <label class="radio-label"><input type="radio" name="tool" value="arrow-curve" onchange="setTool('arrow-curve')">â¤´ ãƒ­ãƒ³ã‚°</label>
                    <label class="radio-label"><input type="radio" name="tool" value="arrow-dashed" onchange="setTool('arrow-dashed')">- - ãƒ©ãƒ³</label>
                    <label class="radio-label"><input type="radio" name="tool" value="arrow-wave" onchange="setTool('arrow-wave')">ã€° ãƒ‰ãƒªãƒ–ãƒ«</label>
                </div>
            </div>

            <div class="control-group">
                <h3>Players</h3>
                <div class="btn-grid">
                    <button class="btn-home" onclick="addPlayer('home', 'FW')">H-FW</button>
                    <button class="btn-home" onclick="addPlayer('home', 'MF')">H-MF</button>
                    <button class="btn-home" onclick="addPlayer('home', 'DF')">H-DF</button>
                    <button class="btn-gk" onclick="addPlayer('home', 'GK')">H-GK</button>
                    <button class="btn-away" onclick="addPlayer('away', 'FW')">A-FW</button>
                    <button class="btn-away" onclick="addPlayer('away', 'MF')">A-MF</button>
                    <button class="btn-away" onclick="addPlayer('away', 'DF')">A-DF</button>
                    <button class="btn-gk" onclick="addPlayer('away', 'GK')">A-GK</button>
                    <button class="btn-cone" onclick="addCone()">â–² ã‚³ãƒ¼ãƒ³è¿½åŠ </button>
                </div>
            </div>

            <div class="control-group">
                <div style="display:flex; gap:5px;">
                    <button class="btn-gray" onclick="undoArrow()">çŸ¢å°æˆ»ã™</button>
                    <button class="btn-gray" onclick="clearArrows()">çŸ¢å°ã‚¯ãƒªã‚¢</button>
                </div>
                <button class="btn-danger" onclick="resetBoard()" style="margin-top:5px;">å…¨ãƒªã‚»ãƒƒãƒˆ</button>
                <div class="trash-info">å‰Šé™¤: ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ / ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—</div>
            </div>
        </div>
    </div>

<script>
    /** è¨­å®šãƒ»å®šæ•° **/
    const canvas = document.getElementById('tacticsBoard');
    const ctx = canvas.getContext('2d');

    const COLORS = {
        pitch: '#4da654',
        line: 'rgba(255, 255, 255, 0.9)',
        home: '#e74c3c',
        away: '#3498db',
        gk: '#f1c40f',
        cone: '#e67e22',
        arrow: '#ffff00'
    };

    /** çŠ¶æ…‹ç®¡ç† **/
    let objects = []; 
    let arrows = [];
    let currentTool = 'move';
    
    // æ“ä½œç”¨
    let isDragging = false;
    let selectedObj = null;
    let isDrawingArrow = false;
    let arrowStartPos = null;

    // ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—åˆ¤å®šç”¨ï¼ˆã‚¹ãƒãƒ›ç”¨ï¼‰
    let lastTapTime = 0;

    /** åˆæœŸåŒ–å‡¦ç† **/
    function init() {
        loadData(); // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰èª­ã¿è¾¼ã¿
        draw();
        
        // è‡ªå‹•ä¿å­˜ãƒ«ãƒ¼ãƒ—
        setInterval(saveData, 2000);
    }

    /** åº§æ¨™å¤‰æ›ï¼ˆé‡è¦: CSSã§ç¸®å°ã•ã‚ŒãŸåº§æ¨™ã‚’Canvaså†…éƒ¨åº§æ¨™800x520ã«å¤‰æ›ï¼‰ **/
    function getPos(e) {
        const rect = canvas.getBoundingClientRect();
        // ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆã‹ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆã‹
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;

        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        return {
            x: (clientX - rect.left) * scaleX,
            y: (clientY - rect.top) * scaleY
        };
    }

    /** ãƒã‚¦ã‚¹ & ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆå…±é€šå‡¦ç† **/
    function handleStart(x, y) {
        // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆé¸æŠåˆ¤å®š
        const clickedObj = [...objects].reverse().find(o => {
            const dx = x - o.x;
            const dy = y - o.y;
            return Math.sqrt(dx*dx + dy*dy) < (o.radius + 10); // å°‘ã—åˆ¤å®šåºƒã‚ã«
        });

        if (currentTool === 'move') {
            if (clickedObj) {
                isDragging = true;
                selectedObj = clickedObj;
            }
        } else {
            isDrawingArrow = true;
            arrowStartPos = { x, y };
        }
    }

    function handleMove(x, y) {
        if (isDragging && selectedObj) {
            selectedObj.x = x;
            selectedObj.y = y;
            draw();
        } else if (isDrawingArrow && arrowStartPos) {
            draw(); 
            drawArrowGraphic(arrowStartPos.x, arrowStartPos.y, x, y, currentTool);
        }
    }

    function handleEnd(x, y) {
        if (isDrawingArrow && arrowStartPos) {
            // x, y ãŒæ¸¡ã•ã‚Œãªã„å ´åˆï¼ˆtouchendãªã©ï¼‰ã‚‚ã‚ã‚‹ã®ã§æ³¨æ„ãŒå¿…è¦ã§ã™ãŒã€
            // ã“ã“ã§ã¯ç°¡æ˜“çš„ã«ç›´å‰ã®æç”»ä½ç½®ã‚’åˆ©ç”¨ã™ã‚‹è¨­è¨ˆã€ã¾ãŸã¯touchendã§ã¯åº§æ¨™ãŒå–ã‚Œãªã„ãŸã‚
            // touchmoveã®æœ€å¾Œã®åº§æ¨™ã‚’ä¿å­˜ã—ã¦ãŠãå¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
            // ç°¡ç•¥åŒ–ã®ãŸã‚ã€touchmoveãªã—ã®ã‚¿ãƒƒãƒ—ã ã‘ã®ç·šã¯å¼•ã‘ãªã„ä»•æ§˜ã¨ã—ã¾ã™ã€‚
        }
        
        // ãƒã‚¦ã‚¹ã‚¢ãƒƒãƒ—æ™‚ã®åº§æ¨™å–å¾—ãŒé›£ã—ã„ãŸã‚ã€
        // å®Ÿéš›ã®å®Ÿè£…ã§ã¯ `handleMove` ã§æ›´æ–°ã—ãŸã€Œæœ€å¾Œã®åº§æ¨™ã€ã‚’ä½¿ã„ã¾ã™ãŒã€
        // HTML Canvasã® `mouseup` ã¯åº§æ¨™å–ã‚Œã¾ã™ã€‚ `touchend` ã¯ changedTouches ã‚’è¦‹ã¾ã™ã€‚
    }

    /** ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ç™»éŒ² (ãƒã‚¦ã‚¹ & ã‚¿ãƒƒãƒ) **/
    
    // Mouse Events
    canvas.addEventListener('mousedown', (e) => {
        const p = getPos(e);
        handleStart(p.x, p.y);
    });
    canvas.addEventListener('mousemove', (e) => {
        const p = getPos(e);
        handleMove(p.x, p.y);
    });
    canvas.addEventListener('mouseup', (e) => {
        const p = getPos(e);
        finishAction(p.x, p.y);
    });

    // Touch Events (ã‚¹ãƒãƒ›å¯¾å¿œ)
    canvas.addEventListener('touchstart', (e) => {
        if(e.touches.length > 1) return; // ãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ ç­‰ã¯è¨±å¯
        e.preventDefault(); // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é˜²æ­¢
        const p = getPos(e);
        
        // ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—åˆ¤å®š
        const currentTime = new Date().getTime();
        const tapLength = currentTime - lastTapTime;
        if (tapLength < 300 && tapLength > 0) {
            // ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—æˆåŠŸ -> å‰Šé™¤å‡¦ç†ã¸
            handleDoubleClick(p.x, p.y);
            e.preventDefault();
        }
        lastTapTime = currentTime;

        handleStart(p.x, p.y);
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault(); // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é˜²æ­¢
        const p = getPos(e);
        handleMove(p.x, p.y);
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
        // touchendã§ã¯ clientXãŒå–ã‚Œãªã„ã®ã§ã€changedTouchesã‚’ä½¿ã†
        const touch = e.changedTouches[0];
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const x = (touch.clientX - rect.left) * scaleX;
        const y = (touch.clientY - rect.top) * scaleY;
        
        finishAction(x, y);
    });

    // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³çµ‚äº†å…±é€šå‡¦ç†
    function finishAction(x, y) {
        if (isDrawingArrow && arrowStartPos) {
            // å§‹ç‚¹ã¨çµ‚ç‚¹ãŒã»ã¼åŒã˜ãªã‚‰æã‹ãªã„ï¼ˆèª¤ã‚¯ãƒªãƒƒã‚¯é˜²æ­¢ï¼‰
            const dist = Math.sqrt((x - arrowStartPos.x)**2 + (y - arrowStartPos.y)**2);
            if(dist > 10) {
                arrows.push({
                    sx: arrowStartPos.x,
                    sy: arrowStartPos.y,
                    ex: x,
                    ey: y,
                    type: currentTool
                });
            }
        }
        isDragging = false;
        selectedObj = null;
        isDrawingArrow = false;
        arrowStartPos = null;
        draw();
        saveData();
    }

    // ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯å‰Šé™¤
    canvas.addEventListener('dblclick', (e) => {
        const p = getPos(e);
        handleDoubleClick(p.x, p.y);
    });

    function handleDoubleClick(x, y) {
        if (currentTool !== 'move') return;
        const idx = objects.findIndex(o => {
            const dx = x - o.x;
            const dy = y - o.y;
            return Math.sqrt(dx*dx + dy*dy) < (o.radius + 10);
        });
        if (idx !== -1) {
            objects.splice(idx, 1);
            draw();
            saveData();
        }
    }


    /** æ©Ÿèƒ½é–¢æ•°ç¾¤ **/

    function addPlayer(team, positionLabel) {
        let color = (team === 'home') ? COLORS.home : COLORS.away;
        if (positionLabel === 'GK') color = COLORS.gk;
        const offsetX = (Math.random() * 60) - 30;
        const offsetY = (Math.random() * 60) - 30;
        objects.push({
            id: Date.now(),
            type: 'player',
            label: positionLabel,
            team: team,
            color: color,
            x: 400 + offsetX,
            y: 260 + offsetY,
            radius: 15
        });
        draw();
        saveData();
    }

    function addCone() {
        objects.push({
            id: Date.now(),
            type: 'cone',
            x: 400 + (Math.random() * 40 - 20),
            y: 260 + (Math.random() * 40 - 20),
            color: COLORS.cone,
            radius: 12
        });
        draw();
        saveData();
    }

    function setTool(tool) { currentTool = tool; }
    function undoArrow() { arrows.pop(); draw(); saveData(); }
    function clearArrows() { arrows = []; draw(); saveData(); }
    function resetBoard() {
        if(confirm("ã™ã¹ã¦å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ")) {
            objects = [];
            arrows = [];
            draw();
            saveData();
        }
    }

    /** ä¿å­˜æ©Ÿèƒ½ **/
    
    // 1. ç”»åƒä¿å­˜
    function downloadImage() {
        // èƒŒæ™¯ã‚’æç”»ã—ã¦ã‹ã‚‰ä¿å­˜ã—ãªã„ã¨é€épngã«ãªã‚‹å ´åˆãŒã‚ã‚‹ãŸã‚ã€ä¸€åº¦draw()å†…ã§èƒŒæ™¯å¡—ã£ã¦ã‚‹ã®ã§OK
        const link = document.createElement('a');
        link.download = 'tactics_board.png';
        link.href = canvas.toDataURL();
        link.click();
    }

    // 2. ãƒ–ãƒ©ã‚¦ã‚¶ä¿å­˜ (Local Storage)
    function saveData() {
        const data = { objects: objects, arrows: arrows };
        localStorage.setItem('tacticsData', JSON.stringify(data));
    }

    function loadData() {
        const data = localStorage.getItem('tacticsData');
        if (data) {
            try {
                const parsed = JSON.parse(data);
                if(parsed.objects) objects = parsed.objects;
                if(parsed.arrows) arrows = parsed.arrows;
            } catch(e) {
                console.error("Save data corrupted");
            }
        }
    }

    /** æç”»ãƒ­ã‚¸ãƒƒã‚¯ (v3ã¨åŒã˜) **/
    function draw() {
        ctx.fillStyle = COLORS.pitch;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawPitchLines();
        arrows.forEach(a => drawArrowGraphic(a.sx, a.sy, a.ex, a.ey, a.type));
        if (isDrawingArrow && arrowStartPos) {
            // mousemove/touchmoveã§ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æç”»æ¸ˆã¿ã ãŒã€å†æç”»æ™‚ã«æ¶ˆãˆãªã„ã‚ˆã†ã“ã“ã§ã‚‚å‘¼ã¶å¿…è¦ã¯ãªã„
            // ãªãœãªã‚‰moveã‚¤ãƒ™ãƒ³ãƒˆã§ draw() -> drawArrowGraphic(preview) ã®é †ã«å‘¼ã¶ãŸã‚ã€‚
        }
        objects.forEach(obj => {
            if (obj.type === 'cone') drawCone(obj);
            else drawPlayer(obj);
        });
    }

    function drawPitchLines() {
        ctx.strokeStyle = COLORS.line;
        ctx.lineWidth = 3;
        ctx.beginPath();
        const m = 30;
        const w = canvas.width - m * 2;
        const h = canvas.height - m * 2;
        ctx.strokeRect(m, m, w, h);
        ctx.moveTo(canvas.width / 2, m);
        ctx.lineTo(canvas.width / 2, canvas.height - m);
        ctx.moveTo(canvas.width / 2 + 60, canvas.height / 2);
        ctx.arc(canvas.width / 2, canvas.height / 2, 60, 0, Math.PI * 2);
        ctx.strokeRect(m, canvas.height/2 - 90, 100, 180);
        ctx.strokeRect(canvas.width - m - 100, canvas.height/2 - 90, 100, 180);
        ctx.strokeRect(m, canvas.height/2 - 35, 40, 70);
        ctx.strokeRect(canvas.width - m - 40, canvas.height/2 - 35, 40, 70);
        ctx.stroke();
    }

    function drawPlayer(p) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
        ctx.fillStyle = p.color;
        ctx.fill();
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = (p.label === 'GK') ? 'black' : 'white';
        ctx.font = 'bold 11px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(p.label, p.x, p.y);
    }

    function drawCone(c) {
        ctx.fillStyle = c.color;
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1;
        const size = 18;
        ctx.beginPath();
        ctx.moveTo(c.x, c.y - size);
        ctx.lineTo(c.x + size/1.5, c.y + size/2);
        ctx.lineTo(c.x - size/1.5, c.y + size/2);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        ctx.beginPath();
        ctx.rect(c.x - 10, c.y + size/2, 20, 3);
        ctx.fillStyle = '#d35400';
        ctx.fill();
    }

    function drawArrowGraphic(sx, sy, ex, ey, type) {
        ctx.strokeStyle = COLORS.arrow;
        ctx.fillStyle = COLORS.arrow;
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.setLineDash([]);
        let angle = Math.atan2(ey - sy, ex - sx);
        ctx.beginPath();

        if (type === 'arrow-curve') {
            const mx = (sx + ex) / 2;
            const my = (sy + ey) / 2;
            const dx = ex - sx;
            const dy = ey - sy;
            const cx = mx - dy * 0.2; 
            const cy = my + dx * 0.2;
            ctx.moveTo(sx, sy);
            ctx.quadraticCurveTo(cx, cy, ex, ey);
            ctx.stroke();
            angle = Math.atan2(ey - cy, ex - cx);
        } else if (type === 'arrow-dashed') {
            ctx.setLineDash([8, 8]);
            ctx.moveTo(sx, sy);
            ctx.lineTo(ex, ey);
            ctx.stroke();
        } else if (type === 'arrow-wave') {
            const dist = Math.sqrt((ex-sx)**2 + (ey-sy)**2);
            const freq = 0.15;
            const amp = 4;
            ctx.save();
            ctx.translate(sx, sy);
            ctx.rotate(angle);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            for (let i = 0; i <= dist; i+=5) ctx.lineTo(i, Math.sin(i * freq) * amp);
            ctx.stroke();
            ctx.restore();
        } else {
            ctx.moveTo(sx, sy);
            ctx.lineTo(ex, ey);
            ctx.stroke();
        }
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.moveTo(ex, ey);
        ctx.lineTo(ex - 12 * Math.cos(angle - Math.PI / 6), ey - 12 * Math.sin(angle - Math.PI / 6));
        ctx.lineTo(ex - 12 * Math.cos(angle + Math.PI / 6), ey - 12 * Math.sin(angle + Math.PI / 6));
        ctx.lineTo(ex, ey);
        ctx.fill();
    }

    init();
</script>
</body>
</html>
